{"version":3,"file":"injector_compatibility.js","sourceRoot":"","sources":["../lib/injector_compatibility.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAY,kBAAkB,EAAE,MAAM,YAAY,CAAC;AAG1D;;;;GAIG;AACH,IAAI,gBAAgB,GAAyB,SAAS,CAAC;AAEvD,MAAM,UAAU,kBAAkB;IAChC,OAAO,gBAAgB,CAAC;AAC1B,CAAC;AAED,MAAM,UAAU,kBAAkB,CAAC,QAA8B;IAC/D,MAAM,MAAM,GAAG,gBAAgB,CAAC;IAChC,gBAAgB,GAAG,QAAQ,CAAC;IAC5B,OAAO,MAAM,CAAC;AAChB,CAAC;AAUD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8DG;AACH,MAAM,UAAU,MAAM,CAAI,KAAuC,EAAE,OAAuB;IACxF,wBAAwB,CAAC,MAAM,CAAC,CAAC;IAEjC,MAAM,aAAa,GAAG,CAAC,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,CAAA,CAAC,CAAC,CAAM,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC;IAC1E,OAAO,gBAAiB,CAAC,GAAG,CAAI,KAAK,EAAE,aAAa,CAAC,CAAC;AACxD,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,qBAAqB,CAAU,QAAkB,EAAE,EAAiB;IAClF,MAAM,YAAY,GAAG,kBAAkB,CAAC,QAAQ,CAAC,CAAC;IAClD,IAAI,CAAC;QACH,OAAO,EAAE,EAAE,CAAC;IACd,CAAC;YAAS,CAAC;QACT,kBAAkB,CAAC,YAAY,CAAC,CAAC;IACnC,CAAC;AACH,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,oBAAoB;IAClC,OAAO,kBAAkB,EAAE,IAAI,IAAI,CAAC;AACtC,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,wBAAwB,CAAC,OAAiB;IACxD,iGAAiG;IACjG,gEAAgE;IAChE,IAAI,CAAC,oBAAoB,EAAE,EAAE,CAAC;QAC5B,MAAM,IAAI,KAAK,CACb,OAAO,CAAC,IAAI;YACV,iKAAiK,CACpK,CAAC;IACJ,CAAC;AACH,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport { Injector, THROW_IF_NOT_FOUND } from './injector';\nimport { ProviderToken } from './provider-token';\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector | undefined = undefined;\n\nexport function getCurrentInjector(): Injector | undefined {\n  return _currentInjector;\n}\n\nexport function setCurrentInjector(injector: Injector | undefined): Injector | undefined {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\nexport interface InjectOptions {\n  optional?: boolean;\n}\n\nexport function inject<T>(token: ProviderToken<T>, options?: InjectOptions & { optional?: false }): T;\nexport function inject<T = any>(token: ProviderToken, options?: InjectOptions & { optional?: false }): T;\nexport function inject<T>(token: ProviderToken<T>, options?: InjectOptions & { optional?: true }): T | null;\nexport function inject<T = any>(token: ProviderToken, options?: InjectOptions & { optional?: true }): T | null;\n/**\n * Injects a token from the currently active injector. `inject` is only supported in an injection\n * context. It can be used during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such as an `@Injectable`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a {@link Provider} or an `@Injectable`.\n * - In a stack-frame of a function call in a DI context (e.g. {@link runInInjectionContext}).\n *\n * @param token A token that represents a dependency that should be injected.\n * @param options Options to configure the inject procedure\n * @param options.optional When set to `true`, the injector will not throw when nothing is found for the token\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws - if called outside a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```ts\n * @Injectable()\n * export class Car {\n *   radio: Radio | undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```ts\n * providers: [\n *   {\n *     provide: Car,\n *     useFactory: () => {\n *       // OK: a class factory\n *       const engine = inject(Engine);\n *       return new Car(engine);\n *     }\n *   }\n * ]\n * ```\n *\n * Calls to the `inject()` function outside the class creation context will result in an error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods, if **not**\n * used in combination with {@link runInInjectionContext}.\n *\n * ```ts\n * @Injectable()\n * export class Car {\n *   init() {\n *     // ERROR: too late, the instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n */\nexport function inject<T>(token: ProviderToken<T> | ProviderToken, options?: InjectOptions): T | null {\n  assertInInjectionContext(inject);\n\n  const notFoundValue = !options?.optional ? <any>THROW_IF_NOT_FOUND : null;\n  return _currentInjector!.get<T>(token, notFoundValue);\n}\n\n/**\n * Runs the given function in the context of the given {@link Injector}.\n *\n * Within the function's stack frame, {@link inject} can be used to inject dependencies\n * from the given {@link Injector}. Note that {@link inject} is only usable synchronously, and cannot be used in\n * any asynchronous callbacks or after any `await` points.\n *\n * @param injector the injector which will satisfy calls to {@link inject} while `fn` is executing\n * @param fn the closure to be run in the context of {@link injector}\n * @returns the return value of the function, if any\n */\nexport function runInInjectionContext<ReturnT>(injector: Injector, fn: () => ReturnT): ReturnT {\n  const prevInjector = setCurrentInjector(injector);\n  try {\n    return fn();\n  } finally {\n    setCurrentInjector(prevInjector);\n  }\n}\n\n/**\n * Whether the current stack frame is inside an injection context.\n */\nexport function isInInjectionContext(): boolean {\n  return getCurrentInjector() != null;\n}\n\n/**\n * Asserts that the current stack frame is within an injection context and has access to `inject`.\n *\n * @param debugFn a reference to the function making the assertion (used for the error message).\n */\nexport function assertInInjectionContext(debugFn: Function): void {\n  // Taking a `Function` instead of a string name here prevents the unminified name of the function\n  // from being retained in the bundle regardless of minification.\n  if (!isInInjectionContext()) {\n    throw new Error(\n      debugFn.name +\n        '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`'\n    );\n  }\n}\n"]}