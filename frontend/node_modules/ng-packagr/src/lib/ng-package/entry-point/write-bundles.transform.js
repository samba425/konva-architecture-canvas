"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeBundlesTransform = void 0;
const ora_1 = __importDefault(require("ora"));
const path_1 = require("path");
const file_watcher_1 = require("../../file-system/file-watcher");
const rollup_1 = require("../../flatten/rollup");
const transform_1 = require("../../graph/transform");
const cache_1 = require("../../utils/cache");
const fs_1 = require("../../utils/fs");
const path_2 = require("../../utils/path");
const nodes_1 = require("../nodes");
const writeBundlesTransform = (options) => (0, transform_1.transformFromPromise)(async (graph) => {
    var _a, _b;
    const entryPoint = graph.find((0, nodes_1.isEntryPointInProgress)());
    const { destinationFiles, entryPoint: ngEntryPoint, tsConfig } = entryPoint.data;
    const cache = entryPoint.cache;
    const { fesm2022Dir, esm2022, declarations, declarationsDir } = destinationFiles;
    const spinner = (0, ora_1.default)({
        hideCursor: false,
        discardStdin: false,
    });
    const cacheKey = await (0, cache_1.generateKey)(ngEntryPoint.moduleId, declarationsDir, fesm2022Dir, tsConfig.options.compilationMode, ((_a = tsConfig.options.declarationMap) !== null && _a !== void 0 ? _a : false).toString());
    const hash = await (0, cache_1.generateKey)([...cache.outputCache.values()].map(({ version }) => version).join(':'));
    const cacheDirectory = options.cacheEnabled && options.cacheDirectory;
    if (cacheDirectory) {
        const cacheResult = await (0, cache_1.readCacheEntry)(options.cacheDirectory, cacheKey);
        if ((cacheResult === null || cacheResult === void 0 ? void 0 : cacheResult.hash) === hash) {
            const filesToCopy = [
                ...cacheResult.fesm2022.map(file => ({
                    ...file,
                    filePath: (0, path_1.join)(fesm2022Dir, file.fileName),
                })),
                ...cacheResult.types.map(file => ({
                    ...file,
                    filePath: (0, path_1.join)(declarationsDir, file.fileName),
                })),
            ];
            try {
                const writeFilePromises = [];
                for (const file of filesToCopy) {
                    if (options.watch && (await (0, fs_1.exists)(file.filePath))) {
                        continue;
                    }
                    if (writeFilePromises.length === 0) {
                        spinner.start('Writing FESM and DTS bundles');
                        await Promise.all([(0, fs_1.mkdir)(fesm2022Dir, { recursive: true }), (0, fs_1.mkdir)(declarationsDir, { recursive: true })]);
                    }
                    writeFilePromises.push((0, fs_1.writeFile)(file.filePath, file.type === 'asset' ? file.source : file.code));
                }
                if (writeFilePromises.length) {
                    await Promise.all(writeFilePromises);
                    spinner.succeed('Writing FESM and DTS bundles');
                }
            }
            catch (error) {
                spinner.fail('Writing FESM and DTS bundles');
                throw error;
            }
            return;
        }
    }
    async function generateBundles() {
        const [{ cache: rollupFESM2022Cache, files: fesmFiles }, { cache: rollupTypesCache, files: typesFiles }] = await Promise.all([
            (0, rollup_1.rollupBundleFile)({
                entry: esm2022,
                entryName: ngEntryPoint.flatModuleFile,
                moduleName: ngEntryPoint.moduleId,
                dir: fesm2022Dir,
                cache: cache.rollupFESM2022Cache,
                cacheDirectory,
                fileCache: cache.outputCache,
                cacheKey,
                sourcemap: true,
            }),
            (0, rollup_1.rollupBundleFile)({
                entry: declarations,
                entryName: ngEntryPoint.flatModuleFile,
                moduleName: ngEntryPoint.moduleId,
                dir: declarationsDir,
                cache: cache.rollupTypesCache,
                cacheDirectory,
                fileCache: cache.outputCache,
                cacheKey,
                sourcemap: tsConfig.options.declarationMap || false,
            }),
        ]);
        cache.rollupFESM2022Cache = rollupFESM2022Cache;
        cache.rollupTypesCache = rollupTypesCache;
        return {
            hash,
            types: typesFiles,
            fesm2022: fesmFiles,
        };
    }
    let cacheRollup;
    try {
        cacheRollup = await generateBundles();
        spinner.succeed(`Generating FESM and DTS bundles`);
        // Invalidate dependent entry-points
        const changedDtsFiles = [];
        for (const file of cacheRollup.types) {
            if (file.type !== 'chunk' || !file.fileName.endsWith('.d.ts')) {
                continue;
            }
            const dtsFile = (0, path_2.ensureUnixPath)((0, path_1.join)(declarationsDir, file.fileName));
            const cachedSourceFile = cache.sourcesFileCache.get(dtsFile);
            if (((_b = cachedSourceFile === null || cachedSourceFile === void 0 ? void 0 : cachedSourceFile.sourceFile) === null || _b === void 0 ? void 0 : _b.text) !== file.code) {
                changedDtsFiles.push(dtsFile);
            }
        }
        if (changedDtsFiles.length) {
            (0, file_watcher_1.invalidateEntryPointsAndCacheOnFileChange)(graph, changedDtsFiles, cache.sourcesFileCache);
        }
    }
    catch (error) {
        spinner.fail();
        throw error;
    }
    if (cacheDirectory) {
        await (0, cache_1.saveCacheEntry)(cacheDirectory, cacheKey, cacheRollup);
    }
});
exports.writeBundlesTransform = writeBundlesTransform;
//# sourceMappingURL=write-bundles.transform.js.map